#include "Image.h"
#include "stdlib.h"
#include "SEEKFREE_FONT.h"
#include "SEEKFREE_18TFT.h"
#include "zf_gpio.h"

uint16 image_gain;  //图像增益
uint16 exposure_time;//摄像头曝光时间
uint16 image_LRoffset;//图像左右偏移量
float gama;
uint16 CONTRAST_THRESHOLD;
uint16 END_TH;     //扫线终止行灰度变化阈值


uint8 GammaTable[256]={0};//γ表

uint8 image[MT9V03X_CSI_H][MT9V03X_CSI_W];  //矫正之后的图像

int16 Lline[MT9V03X_CSI_H];     //左线
int16 Rline[MT9V03X_CSI_H];    //右线
int16 Mline[MT9V03X_CSI_H];      //中线
float AvgGray[MT9V03X_CSI_H];   //图像每行平均灰度

int16 start_point[MT9V03X_CSI_H];   //扫线起始点
int16 last_start_point;             //上一场
uint8 end_line = 10;         //扫线终止行

boder_status left_boder;
boder_status right_boder;

image_status image_s;
pic_info_s pic_info;

const uint8 R_Lline[120]={
5,	7,	9,	11,	13,	15,	17,	19,	21,	22,
23,	25,	26,	27,	28,	30,	30,	32,	34,	35,
36,	37,	39,	40,	42,	42,	44,	45,	46,	46,
48,	50,	52,	53,	54,	55,	56,	58,	58,	60,
62,	62,	64,	65,	66,	68,	69,	70,	72,	73,
74,	76,	77,	78,	80,	81,	82,	84,	85,	86,
88,	89,	90,	92,	93,	94,	96,	96,	98,	99,
100,102,102,104,105,106,108,109,110,111,
112,113,115,115,117,117,119,119,121,122,
124,124,126,126,128,128,130,130,132,133,
134,135,136,137,138,139,140,141,142,143,
144,146,147,149,150,152,153,154,155,156,
};
//const uint8 R_Lline[120]={
//9,10,11,12,13,14,15,16,17,18,
//19,20,21,	22,	24,	25,	27,	28,	29,	31,
//33,	35,	36,	38,	40,	41,	43,	45,	47,	48,
//50,	52,	53,	54,	56,	58,	59,	60,	62,	64,
//66,	68,	70,	71,	72,	74,	76,	77,	79,	81,
//83,	84,	86,	88,	90,	92,	94,	95,	96,	98,
//100,101,103,105,107,108,109,111,113,114,
//115,116,118,120,121,122,124,126,128,129,
//130,131,132,133,135,136,137,138,139,140,
//141,142,143,144,146,147,148,149,150,150,
//159,159,159,159,159,159,159,159,159,159,
//159,159,159,159,159,159,159,159,159,159,
//};

const float Correction_array[120] = {

4.32,4.15,4.00,3.86,3.72,3.48,3.48,3.27,3.18,3.09,
3.275,3.250,3.225,3.200,3.175,3.150,3.125,3.100,3.075,3.050,


3.025,2.950,2.925,2.900,2.875,2.850,2.825,2.800,2.775,2.750,
//    2.975,2.950,2.925,2.900,2.875,2.850,2.825,2.800,2.775,2.750,
2.725,2.700,2.675,2.650,2.625,2.600,2.575,2.550,2.525,2.500,
//    3.265,3.230,3.195,3.160,3.125,3.090,3.055,3.020,2.985,2.950,
//    2.915,2.880,2.845,2.810,2.775,2.600,2.575,2.550,2.525,2.500,
2.475,2.450,2.425,2.400,2.375,2.350,2.325,2.300,2.275,2.250,
2.225,2.200,2.175,2.150,2.125,2.100,2.075,2.050,2.025,2.000,
1.975,1.950,1.925,1.900,1.875,1.850,1.825,1.800,1.775,1.750,
1.725,1.700,1.675,1.650,1.625,1.600,1.575,1.550,1.525,1.500,
1.475,1.450,1.425,1.400,1.375,1.350,1.325,1.300,1.275,1.250,
1.225,1.200,1.175,1.150,1.125,1.100,1.075,1.050,1.025,1.000,

1.06,1.06,1.06,1.05,1.04,1.04,1.04,1.04,1.04,1.03,
1.02,1.02,1.02,1.02,1.02,1.02,1.00,1.00,1.00,1.00
};

void sobel()
{
  uint32 Sy = 0;
  uint32 Gx = 0,Gy = 0; //水平,垂直方向卷积结果
  int16 Sx = 0;
  //第100行扫线起始点
  if(last_start_point)
    start_point[START_ROW-1] = last_start_point;
  else
    start_point[START_ROW-1] = M_INIT;
  
  int i = START_ROW-1;
  //第100行左边缘提取
  for(int j = start_point[START_ROW-1]-2; j > 0; j--)
  {
    Sx = image[START_ROW-1][j+2] - image[START_ROW-1][j];
    if(Sx > 0)
    {
      Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
      Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
      Sy = Gx + Gy;
      if(Sy > CONTRAST_THRESHOLD)
      {
        Lline[i] = j;
        break;
      }
    }
  }
  if(Lline[i] <= 1) Lline[i]=0;
  
  //底部右边缘提取
  for(int j = start_point[START_ROW-1]+2; j < R_INIT; j++)
  {
    Sx = image[START_ROW-1][j-2] - image[START_ROW-1][j];
    if(Sx > 0)
    {
      Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
      Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
      Sy = Gx + Gy;
      if(Sy > CONTRAST_THRESHOLD)
      {
        Rline[i] = j;
        break;
      }
    }
  }
  if(Rline[i] >= R_INIT-1) Rline[i]=R_INIT;
  
//  for(int j = Lline[START_ROW-1]; j <= Rline[START_ROW-1]; j++)
//     AvgGray[START_ROW-1] += image[START_ROW-1][j];
//  AvgGray[START_ROW-1] = AvgGray[START_ROW-1]/(float)(Rline[START_ROW-1]-Lline[START_ROW-1]);
  
  //其他行采用本场上一行的扫线起点，隔行扫线即可
  for(int i = START_ROW-2; i >= end_line; i--)
  {
    start_point[i] = (Lline[i+1] + Rline[i+1])/2;
    int temp = start_point[i] - start_point[i+1];
//    if(temp >= 5)
//      start_point[i] = start_point[i+1]+5;
//    else if(temp <= -5)
//      start_point[i] = start_point[i+1]-5;
    if(temp <= -5|| temp >=5)
    {
        //左边为丢线，右边有线
        if(Lline[i+1] == L_INIT && Rline[i+1]!=R_INIT)
            start_point[i] = Rline[i+1] -R_Lline[i]/2;
        //右边为丢线，左边有线
        else if(Lline[i+1] != L_INIT && Rline[i+1] == R_INIT)
            start_point[i] = Lline[i+1] +R_Lline[i]/2;
        //其他情况
        else
            start_point[i]=start_point[i+1];
        if(start_point[i]>=R_INIT||start_point[i]<=L_INIT)
          start_point[i] = M_INIT;
    }
    
    //左边缘提取
    for(int j = start_point[i]-1; j > 0; j--)
    {
      Sx = image[i][j+1] - image[i][j-1]; 
      if(Sx > 0)
      {
        Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
        Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
        Sy = Gx + Gy;
        if(Sy > CONTRAST_THRESHOLD)
        {
          Lline[i] = j;
          break;
        }
      }
    }
    if(Lline[i] <= 1)   Lline[i] = 0;
    
    for(int j = start_point[i]+1; j < R_INIT; j++)
    {
      Sx = image[i][j-1] - image[i][j+1];
      if(Sx > 0)
      {
        Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
        Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
        Sy = Gx + Gy;
        if(Sy > CONTRAST_THRESHOLD)
        {
          Rline[i] = j;
          break;
        }
      }
    }
    if(Rline[i] >= R_INIT-1) Rline[i]=R_INIT;
    
//    if(i <= 55)
//    {
//      for(int j = Lline[i]; j <= Rline[i]; j++)
//         AvgGray[i] += image[i][j];
//      AvgGray[i] = AvgGray[i]/(float)(Rline[i]-Lline[i]);
//      if((AvgGray[i]- AvgGray[i+2]) < -END_TH)
//      {
//        image_s.endline = i;
//        break;
//      }
//    }
  }

//  if(image_s.endline <end_line)
//      image_s.endline = end_line;
  last_start_point = start_point[START_ROW-2];
}

void get_endline()
{
  for(int i = 55; i > 0; i--)
  {
    AvgGray[i]=0;
    for(int j = Lline[i]; j<=Rline[i]; j++)
      AvgGray[i] += image[i][j];
    AvgGray[i] = AvgGray[i]/(float)(Rline[i]-Lline[i]);
    if((AvgGray[i]- AvgGray[i+2]) < -END_TH)
    {
      image_s.endline = i;
      break;
    }
  }
  if(image_s.endline <end_line)
    image_s.endline = end_line;
//  for(int i = MT9V03X_CSI_H - 3; i > end_line; i--)
//  {
//    if((AvgGray[i]- AvgGray[i+2]) < -END_TH)
//    {
//      image_s.endline = i;
//      break;
//    }
//  }

}
void image_midline_get()
{
  for(uint8 i = START_ROW - 1; i>image_s.endline; i--)
  {
    if(Lline[i]>=5 && Rline[i] <= R_INIT-5)//左右均无丢线
      Mline[i] = (Rline[i] + Lline[i])/2;
    else if(Lline[i] >= M_INIT-R_Lline[i]/2 && Rline[i]>R_INIT-10 && Rline[i]<=R_INIT)//左线有效，右线无
      Mline[i] = Lline[i] + R_Lline[i+12]/2;
    else if(Rline[i]<M_INIT+R_Lline[i]/2 && Lline[i]>=L_INIT && Lline[i]<10)//右线有效，左线无效
      Mline[i] = Rline[i] - R_Lline[i+12]/2;
    else
      Mline[i] = (Rline[i] + Lline[i])/2;
    if(Mline[i]<L_INIT)
      Mline[i] = L_INIT;
    else if(Mline[i]>R_INIT)
      Mline[i] = R_INIT;
  }
  for(uint8 i = START_ROW; i>image_s.endline;i--)
    image_s.error += (Mline[i]-M_INIT)*Correction_array[i];
  image_s.error = image_s.error/(START_ROW-image_s.endline);
}

//build gama table
void BuildGamaTable(float coefficient)// called in initialization
{
  float f;
  for(int i = 0;i < 256; i++)
  {
    f = (i + 0.5)/256;  //normalized
    f = (float)pow(f, coefficient);
    GammaTable[i] = (uint8)(f*256 - 0.5);   //denormalized
  }
}

void ImageGamaCorrect()
{
  for(int row = 0; row < MT9V03X_CSI_H; row++)
    for(int col = 0; col < MT9V03X_CSI_W; col++)
    {
      image[row][col] = GammaTable[mt9v03x_csi_image[row][col]];
    }
}
void edge()
{
  ImageGamaCorrect();
  sobel();
}

void edge_show()
{
  //左右边缘显示
  for(uint8 i = image_s.endline; i < START_ROW; i++)
  {
//    lcd_drawpoint(Lline[i], i, PURPLE);
//    lcd_drawpoint(Rline[i], i, GREEN);
    
    LCD_Fill(Lline[i],i,Lline[i],i,PURPLE);
    LCD_Fill(Rline[i],i,Rline[i],i,GREEN);
    LCD_Fill(Mline[i],i,Mline[i],i,YELLOW);
    LCD_Fill(start_point[i],i,start_point[i],i,RED);
  }
  for(int i = 0; i<MT9V03X_CSI_W; i++)
  {
     LCD_Fill(i,image_s.endline,i,image_s.endline,RED);
     LCD_Fill(i,START_ROW,i,START_ROW,RED);
  }
  
  for(int i = 0; i<MT9V03X_CSI_H; i++)
    LCD_Fill(79,i,79,i,RED);
}

void track_mark_show()
{
//  //丢线显示
//  for(int i = 0;i < left_boder.lost_count; i++)
//  {
//    lcd_drawpoint(left_boder.lost_head[i], L_INIT, BLUE);
//    lcd_drawpoint(left_boder.lost_head[i]+1, L_INIT, BLUE);
//        lcd_drawpoint(left_boder.lost_head[i], L_INIT+1, BLUE);
//    lcd_drawpoint(left_boder.lost_head[i]+1, L_INIT+1, BLUE);
//  }
  
}

void image_show()
{
  uint16 temp = 0,color = 0;
  lcd_set_region(0,0,MT9V03X_CSI_W-1,MT9V03X_CSI_H-1);
  for(int i = 0; i < MT9V03X_CSI_H; i++)
  {
    for(int j = 0; j < MT9V03X_CSI_W; j++)
    {
      if(i == left_boder.breakpoint && j>=Lline[i]-5 && j<=Lline[i]+5)//左拐点
        lcd_writedata_16bit(BLACK);
      else if(i==right_boder.breakpoint && j>=Rline[i]-5 && j<=Rline[i]+5)//右拐点
        lcd_writedata_16bit(BROWN);
      else if(i == left_boder.breakpoint_up && j>=Lline[i]-5 && j<=Lline[i]+5)//左上拐点
        lcd_writedata_16bit(RED);
      else if(i==right_boder.breakpoint_up && j>=Rline[i]-5 && j<=Rline[i]+5)//右上拐点
        lcd_writedata_16bit(YELLOW);
      else if(i==right_boder.lost_tail[0] &&(j>140&&j<160)) //右丢线
          lcd_writedata_16bit(PINK);
      else if(i==right_boder.lost_tail[1] &&(j>140&&j<160))
          lcd_writedata_16bit(PINK);
      else if(i==right_boder.lost_head[0] &&(j>140&&j<160))
          lcd_writedata_16bit(PURPLE);
      else if(i==right_boder.lost_head[1] &&(j>140&&j<160))
          lcd_writedata_16bit(PURPLE);
      else if(i==left_boder.lost_tail[0] &&(j>=0&&j<20))//左丢线
          lcd_writedata_16bit(PINK);
      else if(i==left_boder.lost_tail[1] &&(j>=0&&j<20))
          lcd_writedata_16bit(PINK);
      else if(i==left_boder.lost_head[0] &&(j>=0&&j<20))
          lcd_writedata_16bit(PURPLE);
      else if(i==left_boder.lost_head[1] &&(j>=0&&j<20))
          lcd_writedata_16bit(PURPLE);
      else
      {
        temp = image[i][j];
        color=(0x001f&((temp)>>3))<<11;
        color=color|(((0x003f)&((temp)>>2))<<5);
        color=color|(0x001f&((temp)>>3));
        lcd_writedata_16bit(color);
      }
    }
  }
}
void line_init()
{
  for(int i = 0;i < MT9V03X_CSI_H;i++)
  {
    Lline[i] = L_INIT;
    Rline[i] = R_INIT;
    Mline[i] = M_INIT;
  }
}
void image_hanldle()
{
  line_init();
  edge();
  get_endline();
  
  //计算斜率
  first_derivative(&left_boder, Lline);
  first_derivative(&right_boder, Rline);
  
  //寻找拐点
  find_breakpoint(&left_boder, Lline,image_s.endline,'l');
  find_breakpoint(&right_boder, Rline,image_s.endline,'r');
  
//  //寻找上拐点
  find_breakpoint_up(&left_boder, Lline,image_s.endline,'l');
  find_breakpoint_up(&right_boder, Rline,image_s.endline,'r');
  
  //丢线
  find_lost_line(Lline, &left_boder, 'l');
  find_lost_line(Rline, &right_boder, 'r');
  
  circle_judge_r(&left_boder, &right_boder, &pic_info);
  
//  circle_handle_r(pic_info.circle_e,&left_boder, &right_boder);
  
  image_midline_get();
}

//计算斜率
void first_derivative(boder_status *boder, int16 *line)
{
  for(uint8 i = START_ROW-2; i > end_line; i--)
    boder->first_deriva[i] = (line[i+1] - line[i-1])/2.0;
}

//寻找拐点
void find_breakpoint(boder_status *boder, int16 *line, int16 end, char flag)
{
  int8 breakpoint_th = 3;
  uint8 count1 = 0,count2 = 0;
  boder->breakpoint = 0;
  
  //左拐点
  if(flag == 'l')
  {
    for(uint8 i = START_ROW-20-2; i > end+4; i--)
    {
      if(line[i]-line[i-3] <= 0)
      {
        if(count2 != 0)
          count1 = 0;
        count1++;
        count2 = 0;
      }
      else if((!count2 && line[i]-line[i-3] > breakpoint_th)|| count2)
      {
        count2++;
        if(count1 > 2 && count2 >2)
        {
          boder->breakpoint = i+1;
          break;
        }
      }
    }
  }
  else if(flag == 'r')
  {
    for(uint8 i = START_ROW-20-2; i > end+4; i--)
    {
      if(line[i] - line[i-3] >= 0)
      {
        if(count2)
          count1 = 0;
        count1++;
        count2 = 0;
      }
      else if((!count2 && line[i]-line[i-3] < -breakpoint_th)||count2)
      {
        count2++;
        if(count1 >2 && count2 > 2)
        {
          boder->breakpoint = i+1;
          break;
        }
      }
    }
  }
}

void find_breakpoint_up(boder_status *boder, int16 *line, int16 end, char flag)
{
  int8 breakpoint_th = 5;
  uint8 count1 = 0,count2 = 0;
  boder->breakpoint_up = 0;
  
  //左拐点
  if(flag == 'l')
  {
    for(uint8 i = START_ROW-20-2; i > end+4; i--)
    {
      if(line[i]-line[i-3] <= -breakpoint_th)
      {
        if(count2)
          count1 = 0;
        count1++;
        count2 = 0;
      }
      else if((!count2 && line[i]-line[i-3] > -10)&&line[i]-line[i-3]<=0|| count2)
      {
        count2++;
        if(count1 > 2 && count2 >=3 &&((line[i]-line[i+3])-(line[i-3]-line[i]))>2)
        {
          boder->breakpoint_up = i+count2-1;
          break;
        }
      }
    }
  }
  else if(flag == 'r')
  {
    for(uint8 i = START_ROW-20-2; i > end+4; i--)
    {
      if(line[i] - line[i-3] >= breakpoint_th)
      {
        if(count2)
          count1 = 0;
        count1++;
        count2 = 0;
      }
      else if((!count2 && line[i]-line[i-3] <= 10)&&line[i]-line[i-3]>=0||count2)
      {
        count2++;
        if(count1 >2 && count2 >= 2&&(line[i+3]-line[i])-(line[i]-line[i-3])>2)
        {
          boder->breakpoint_up = i+count2-1;
          break;
        }
      }
    }
  }
}

//找丢线
void find_lost_line(int16 *line, boder_status *boder, char flag)
{
  int8 count,loop,total,lost_th = 9;
  
  count = loop = total = 0;
  boder->lost_head[0] = START_ROW;
  boder->lost_tail[0] = START_ROW;
  boder->lost_head[1] = START_ROW;
  boder->lost_tail[1] = START_ROW;
  
  if(flag == 'l')
  {
    for(int i = START_ROW-1; i > image_s.endline; i--)
    {       //已经到了结束行           找到了丢线头部            没找到丢线尾部           丢线第一或第二段
      if(i==image_s.endline+1 && boder->lost_head[count]!=START_ROW && boder->lost_tail[count]==START_ROW && count<=1)
      {     
        if(boder->lost_head[count]-i >= lost_th)
        {
          boder->lost_tail[count] = i;
          count++;
        }
        else
          boder->lost_head[count] = START_ROW;
        break;
      }
      if(line[i] <= 0)
      {
        loop++; //每段丢线行数计数
        total++;//丢线总行数
        if(boder->lost_head[count] == START_ROW)
          boder->lost_head[count]=i;
      }
      else if(loop)
      {
        if(boder->lost_head[count]!=START_ROW)
          boder->lost_tail[count] = i; //有头部，给尾部
        count++;    //找下一段丢线
        if(loop < lost_th)  //丢线太短，舍弃
        {
          count--;
          boder->lost_head[count] = START_ROW;
          boder->lost_tail[count] = START_ROW;
        }
        if(count >=2)
          break;
        loop = 0;
      }
    }
  }
  else if(flag == 'r')
  {
    for(int i = START_ROW-1; i > image_s.endline; i--)
    {       //已经到了结束行           找到了丢线头部            没找到丢线尾部           丢线第一或第二段
      if(i==image_s.endline+1 && boder->lost_head[count]!=START_ROW && boder->lost_tail[count]==START_ROW && count<=1)
      {     
        if(boder->lost_head[count]-i >= lost_th)
        {
          boder->lost_tail[count] = i;
          count++;
        }
        else
          boder->lost_head[count] = START_ROW;
        break;
      }
      if(line[i] >= R_INIT)
      {
        loop++; //每段丢线行数计数
        total++;//丢线总行数
        if(boder->lost_head[count]==START_ROW)
          boder->lost_head[count]=i;
      }
      else if(loop)
      {
        if(boder->lost_head[count]!=START_ROW)
          boder->lost_tail[count] = i; //有头部，给尾部
        count++;    //找下一段丢线
        if(loop < lost_th)  //丢线太短，舍弃
        {
          count--;
          boder->lost_head[count] = START_ROW;
          boder->lost_tail[count] = START_ROW;
        }
        if(count >=2)
          break;
        loop = 0;
      }
    }
  }
  
  boder->lost_count = count;//丢线区域计数器 0，1 or 2
  boder->lost_total = total;//所有丢线区域的总丢线行数
  if(count == 1)
  {
    boder->lost_head[1] = START_ROW;
    boder->lost_tail[1] = START_ROW;
  }
}
int a,b,c,d,e,f;
void circle_judge_r(boder_status *l, boder_status *r, pic_info_s * pic)
{

  d=abs(r->lost_head[0]-r->breakpoint)<25;
  e=(l->lost_total<5 && r->lost_total < 35);
  f=  (l->breakpoint == 0 && r->breakpoint>r->lost_head[0]);
  if(pic->circle_e == NOCICLE && pic->elem_type == COMMON)
  {

    if(l->lost_count <=1 && (l->lost_head[0] >75 || l->lost_head[0]==0) && l->lost_total <10
         && r->breakpoint >= 10&&r->breakpoint<=75 && abs(l->breakpoint-r->breakpoint)>10
         && slope_range(l->lost_tail[0]-5,image_s.endline+2, l->first_deriva) < 2//左边是直线
         && slope_range(r->lost_tail[0]-5,r->breakpoint+5,r->first_deriva) < 2  //拐点下是直线
         && deviate_mid('L',18) == 1 && deviate_mid('R',18) == 1//保证左边正常  
         && abs(r->lost_head[0] - r->breakpoint)<10
           )
    {
      pic_info.elem_type = CIRCLE;
      pic_info.circle_e = RIGHT;
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT)
  {
    if(r->breakpoint<28 && r->lost_tail[0]>=30 && r->lost_tail[0]<80)
    {
      pic->elem_type = CIRCLE;
      pic->circle_e = RIGHT_BEFORE;
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_BEFORE)
  {
    track_again_huandao(40,image_s.endline,'r');
    find_breakpoint_up(&right_boder, Rline, 'r');
    first_derivative(&right_boder, Rline);
    
    int cnt = 0;//上拐点下面是丢线
    for(int i = 0; i<15;i++)
    {
      if(Rline[i+r->breakpoint_up]<R_INIT-20)
        cnt++;
    }
    if(cnt<=3 && r->breakpoint_up<50 && Rline[r->breakpoint_up]<R_INIT-30
       && Rline[r->breakpoint_up]
       && slope_range(l->lost_tail[0]-4,20,l->first_deriva)<2.0//左边是直线
       && slope_range(r->breakpoint_up-4,image_s.endline,r->first_deriva)<2.0  
         )
    {
      pic->elem_type = CIRCLE;
      pic->circle_e = RIGHT_IN;
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_IN)
//  if(pic->circle_e == NOCICLE && pic->elem_type == COMMON)
  {
    track_again_huandao(START_ROW-10,end_line,'r');
    gpio_toggle(B9);
    find_breakpoint(&right_boder,Rline,end_line,'r');
    find_breakpoint_up(&right_boder,Rline,end_line,'r');
    a=(slope_range(l->lost_tail[0]-4,image_s.endline+10,l->first_deriva)>2);
    b=(slope_range(START_ROW-1,START_ROW-10,l->first_deriva) > 2);
    c=(l->lost_total<5);
//    gpio_toggle(B9);
    if(r->breakpoint_up==0&&l->breakpoint_up==0
       &&l->lost_total<5)
    {
      pic->elem_type = CIRCLE;
      pic->circle_e = RCIRCLE_IN;
//      gpio_toggle(B9);
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RCIRCLE_IN)
  {
    
    if(l->breakpoint > 40 && Lline[l->breakpoint]>2 && Lline[l->breakpoint]<M_INIT+40//出现拐点，并正常
       && slope_range(l->lost_tail[0]-10,l->breakpoint+8,l->first_deriva)<=3
       )
    {
      pic->elem_type = CIRCLE;
      pic->circle_e = RIGHT_OUT;
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_OUT)
  {
    if(slope_range(l->lost_tail[0]-10,image_s.endline+10,l->first_deriva)<2.0
       && l->lost_total<5)
    {
      pic->elem_type = CIRCLE;
      pic->circle_e = RIGHT_END;
    }
  }
  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_END)
  {
    if((l->breakpoint_up>=45||l->breakpoint_up==0)
        && slope_range(l->lost_tail[0]-10,image_s.endline+10,l->first_deriva)<1.9
        && slope_range(r->lost_tail[0]-10,image_s.endline+10,r->first_deriva)<1.9
        &&(l->lost_total+r->lost_total)<5
          )
    {
      pic->elem_type = COMMON;
      pic->circle_e = NOCICLE;
    }
  }
    
//  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_BEFORE)
//  {
//    if(r->breakpoint > 40 && r->breakpoint<75 
//        && r->lost_head[0]>30 && r->lost_head[0]<50 && r->lost_total<40
//        && abs(r->lost_head[0]-r->breakpoint)<25)
//    {
//      pic->elem_type = CIRCLE;
//      pic->circle_e = RIGHT_IN;
//    }
//  }

//  if(pic->elem_type == CIRCLE && pic->circle_e == RIGHT_IN)
//  {
//    if(l->lost_total<5 && r->lost_total < 35 
//        && l->breakpoint == 0 && r->breakpoint>r->lost_head[0])
//    {
//      pic->elem_type = CIRCLE;
//      pic->circle_e = RCIRCLE_IN;
//    }
//  }
}
void circle_handle_r(circle_status_e flag, boder_status *l, boder_status *r)
{
  if(flag == RIGHT)
  {
    matchline_pingyi(START_ROW, image_s.endline,'r');
  }
  if(flag == RIGHT_BEFORE)
  {
    matchline_pingyi(START_ROW, image_s.endline,'r');
  }
  if(flag == RIGHT_IN)
  {
//    track_again_huandao(45,end_line,'r');
    if(r->breakpoint_up)
    {
      Arc_matchlineLY(0,START_ROW,Rline[r->breakpoint_up],r->breakpoint_up,Lline,'o');
      line_pingyi(START_ROW,image_s.endline,3,'l');
    }
    else if(r->lost_count == 1)
    {
      Arc_matchlineLY(Lline[r->lost_head[0]],r->lost_head[0],Rline[r->lost_tail[0]],r->lost_tail[0],Lline,'o');
      line_pingyi(START_ROW,r->lost_tail[0],3,'l');
      matchline_pingyi(r->lost_tail[0],image_s.endline,'r');
    }
    else
    {
      Arc_matchlineLY(0, START_ROW,  135, 35, Lline,'o');
      line_pingyi(START_ROW,35,2.5,'l');
    }
  }
  if(flag == RCIRCLE_IN)
  {
    
  }
  if(flag == RIGHT_OUT)
  {
    if(l->breakpoint)
    {
      Arc_matchlineLY(Lline[l->breakpoint],l->breakpoint,R_INIT,image_s.endline,Lline,'o');
    }
    else if(r->lost_count == 1)
    {
      Arc_matchlineLY(Lline[r->lost_head[0]],r->lost_head[0],R_INIT,r->lost_tail[0],Lline,'o');
    }
  }
  if(flag == RIGHT_END)
  {
    matchline_pingyi(START_ROW, image_s.endline,'r');
  }
}


float slope_range(int16 start, int16 end, float *line)
{
  float max, min;
  
  max = -999;
  min = 999;
  
  if(end < end_line)
    end = end_line;
  for(int i = start; i >= end; i--)
  {
    if(line[i] > max)
      max = line[i];
    if(line[i] < min)
      min = line[i];
  }
  return (max - min);
}

int deviate_mid(char flag,int16 end)
{
  int row,count=0,start = 50,step=5;
  if(flag == 'l'||flag == 'L')
  {
    for(row = start ; row > end ; row--)
    {
      if(Lline[row] > M_INIT-step)
        count++;
    }
  }
  if(flag == 'r'||flag == 'R')
  {
    for(row = start ; row > end ; row--)
    {
      if(Rline[row] < M_INIT+step)
        count++;
    }
  }
  if(count > start - end)
      return 0;
  else
      return 1;
}



//环岛重新扫线
void track_again_huandao(int16 start,int16 end,char flag)
{
  uint32 Sy = 0,Gx,Gy;
  int i,j;
  int16 Sx = 0;
  if(flag=='l'||flag=='L')
  {
    for(i = start - 2; i > end; i--)
    {//左环岛,以右线为基准线往左扫线

      start_point[i] = Rline[i+1] - R_Lline[i+1]/3;
      for(j = start_point[i]-1; j > 0; j--)
      {
        Sx = image[i][j+1] - image[i][j-1];        
        if(Sx > 0)
        {
          Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
          Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
          Sy = Gx + Gy;
          if(Sy > CONTRAST_THRESHOLD)
          {
            Lline[i] = j;
            break;
          }
        }
      }
      Lline[i] = j;
      if(Lline[i]<=1)Lline[i]=0;
      
      for(j = start_point[i]+1; j<R_INIT;j++)
      {
        Sx = image[i][j-1] - image[i][j+1];
        if(Sx > 0)
        {
          Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
          Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
          Sy = Gx + Gy;
          if(Sy > CONTRAST_THRESHOLD)
          {
            Rline[i] = j;
            break;
          }
        } 
      }
      Rline[i] = j;
      if(Rline[i] >= R_INIT-1) Rline[i]=R_INIT;
    }
  }
  if(flag=='r'||flag=='R')
  {
    for(i = start - 2; i > end; i--)
    {//从起始扫到结束
      start_point[i] = Lline[i+2] +  R_Lline[i+2]/4;
      for(j = start_point[i]+1; j < R_INIT; j++)
      {
        Sx = image[i][j-1] - image[i][j+1];
        if(Sx > 0)
        {
          Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
          Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
          Sy = Gx + Gy;
          if(Sy > CONTRAST_THRESHOLD)
          {
            Rline[i] = j;
            break;
          }
        }
      }
      Rline[i] = j;
      if(Rline[i]>=R_INIT-1)Rline[i]=R_INIT;
      
      for(j = start_point[i]-1; j > 0; j--)
      {
        Sx = image[i][j+1] - image[i][j-1]; 
        if(Sx > 0)
        {
          Gx = abs(image[i-1][j-1]+2*image[i][j-1]+image[i+1][j-1]-image[i-1][j+1]-2*image[i][j+1]-image[i+1][j+1]);
          Gy = abs(image[i-1][j-1]+2*image[i-1][j]+image[i-1][j+1]-image[i+1][j-1]-2*image[i+1][j]-image[i+1][j+1]);
          Sy = Gx + Gy;
          if(Sy > CONTRAST_THRESHOLD)
          {
            Lline[i] = j;
            break;
          }
        }
      }
      Lline[i] = j;
      if(Lline[i] <= 1)   Lline[i] = 0;
    }
  }
}

void matchline_pingyi(int16 start,int16 end,char flag)
{//平移赛道宽度补线
  int i=0;
  if(start<=end)  return;
  if(flag=='l'||flag=='L')//补左线
  {
    for(i=start;i>=end;i--)
    {
      Lline[i]=Rline[i]-R_Lline[i];
      if(Lline[i] <= 0) Lline[i] = 0;
    }
  }
  else if(flag=='r'||flag=='R')
  {
    for(i=start;i>=end;i--)
    {
      Rline[i]=Lline[i]+R_Lline[i];
      if(Rline[i] >= R_INIT) Rline[i] = R_INIT;
    }
  }
}

void line_pingyi(int16 start, int16 end,float times, char flag)
{
  int i=0;
  if(start<=end)  return;
  if(flag=='l'||flag=='L')//补左线
  {
    for(i=start;i>=end;i--)
    {
      Lline[i]=Lline[i]+(int16)(R_Lline[i]/times);
      if(Lline[i] >= R_INIT) Lline[i] = R_INIT-10;
    }
  }
  else if(flag=='r'||flag=='R')
  {
    for(i=start;i>=end;i--)
    {
      Rline[i]=Rline[i]-(int16)(R_Lline[i]/times);
      if(Rline[i] < L_INIT) Rline[i] = L_INIT+10;
    }
  }
}
void Arc_matchlineLY(int16 col1, int16 row1, int16 col2, int16 row2, int16* line, char d)//两点圆弧连线(原点轴为Y轴)
{
    if(row1<=row2||col1>=col2)  return;
    row1 = row1 > START_ROW-1 ? START_ROW-1 : row1;
    row2 = row2 < 1 ? 1 : row2;
    int16 x0 = col2-col1, y0 = row1-row2;
    int16 sign = 1;
    if(x0 < 0)  sign = -1;
    float R = (float)(((x0)*(x0) + (y0)*(y0))/(y0<<1));
    float R2 = R*R;
    float loop;
    for(int16 i = row1;i >= row2;i--)
    {
        if(d == 'U')
        {
            loop = R2 -(R-row1+i)*(R-row1+i);
            line[i] = (int16)(col1 + sign * sqrt(loop));
        }
        else
        {
            loop = R2 -(R+row2-i)*(R+row2-i);
            line[i] = (int16)(col2 - sign * sqrt(loop));
        }
        if(line[i] < 0)  line[i] = 0;
        else if(line[i] > R_INIT)  line[i] = R_INIT;
    }
}